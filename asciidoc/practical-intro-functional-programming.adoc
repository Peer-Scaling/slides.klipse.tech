= A practical introduction to Functional Programming
:encoding: utf-8
:navigation:
:deckjs_transition: horizontal-slide
:menu:
:status:
:deckjs_theme: none
:hardbreaks:

== Who am I?
[.left]
--
- Yehonathan Sharvit https://twitter.com/viebel[@viebel]
- A mathematician
- A coder
- A pragmatic theorist
- A freak of interactivity
- Founded Audyx in 2013 - an Audiology Startup with 30K LOCs in Clojurescript
- Author of https://github.com/viebel/klipse[Klipse] - a simple client-side code evaluator pluggable on any web page 
++++
                      <a class="github-button" href="https://github.com/viebel/klipse" data-count-href="/viebel/klipse/stargazers" data-count-api="/repos/viebel/klipse#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star viebel/klipse on GitHub">KLIPSE</a>
                    <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
++++
- A Web consultant: Full-Stack, clojure{,script}, ruby{, on rails}, javascript, react
- A https://www.codementor.io/yehonathansharvit[CodeMentor Xpert] (You can hire me!)
--

image::https://pbs.twimg.com/profile_images/713278171353911296/1a2useM2.jpg[me]


== Agenda

- The Paradigms of Functional Programming
- A brief history of Functional Programming
- Functional Programming in practice
- Discussion and Questions

== The paradigms of Functional Programming

* Functions are first class citizens
* Declarative
* Pure Functions
* Immutability
* Laziness

== Functions - first class citizens

[%step]
--
* Functions can be passed to variable definitions
* Functions can be passed as arguments to functions
* Functions can return functions
--

== Functions - passed to variable definitions

[%step]
--
Javascript
[source.eval-js]
----
function foo() { return 42}
var bar = function() { return 43}
x = [foo(), bar()]
----

--
[%step]
--
EcmaScript6
[source.eval-js]
----
baz = () => 42
baz()
----
--

[%step]
--
Clojure
[source.clj]
----
(defn foox [] 42)
(def bax (fn [] 43))
[(foox) (bax)]
----
--

[%step]
--
Ruby
[source.ruby]
----
def foow
  42
end
baw  = ->() { 43 }
[foow(), baw[]]
----
--



== Functions - passed as arguments to functions

In function languages, you can create anonymous functions i.e. functions that don't have a name.

[%step]
--
Javascript
[source.eval-js]
----
[1,2,3].map(function(x) { return x + 1})
----

--
[%step]
--
EcmaScript6
[source.eval-js]
----
[1,2,3].map((x) => x+1)
----
--

[%step]
--
Clojure
[source.clj]
----
(map inc [1 2 3])
----
--

[%step]
--
Ruby
[source.ruby]
----
[1,2,3].map {|x|
  x + 1
  }
----
--

== Functions that return functions

An important function in FP is `partial` (or `curry`).

`partial` takes a function and a list of arguments and returns a function where some arguments are fixed.

Let's see it in action!

[%step]
--
Javascript
We are going to use http://ramdajs.com/[Ramda].
[source.eval-js]
----
function add(x, y) { return x + y}
var add10 = R.partial(add, [10])
add10(19)
----

--
[%step]
--
EcmaScript6
[source.eval-js]
----
const add = (x, y) => x + y
const add10 = R.partial(add, [10])
add10(19)
----
--

[%step]
--
Clojure
[source.clj]
----
(defn add [x y] (+ x y))
(let [add10 (partial add 10)]
  (add10 32))
----
--

[%step]
--
Ruby
In ruby, it's called `curry`.
[source.ruby]
----
add  = ->(x,y) do x + y end
add10 = add.curry.(10)
add10.(9)
----
--

== Exercise

Let's write our own version of `partial` in ES6

[%step]
--
[source.eval-js]
----
partial = () => 1

----
--

[%step]
--
[source.eval-js]
----
partial = (f, x) => (y) => f(x, y)
partial(add, 10)(9)
----
--

== Declarative style

Let's compare `map` and `for` in javascript.

With `map`, you don't deal with low-level details
You only express what to do with each element of the array.

[%step]
--
[source.eval-js]
----
[1,2,3].map(x => x + 1)
----
--

[%step]
--
With `for`, you have deal with low-level details.

You have to express:

* how the array is iterated
* what is the name of the index
* how the elements are combined in the returned array

[source.eval-js]
----
const arr = [1,2,3]
const f = x => x + 1
let retArr = []
for(let i = 0; i < arr.length; i++) {
  retArr.push(f(arr[i]))
}
retArr
----
--

== Pure functions

[%step]
--
A pure function

* depends only on its parameters (not on a global state)
* has no side effects
--

[%step]
--
Pure functions are much simpler

* to combine
* to test
* to debug
* to understand
* to refactor
--

== Pure functions - no implicit dependencies


[%step]
--
This function depends on a global parameter
[source.eval-js]
----
const N = 1e9
const rand = () => Math.round(N*Math.random())
rand()
----
--

[%step]
--
Let's rewrite it as a pure function
[source.eval-js]
----
const rand = (max) => Math.round(max*Math.random())
rand(1e9)
----
--

== Pure functions - no side effects

[%step]
--
This function writes the error to the console in case of a failure.

How will you test such a function?
[source.eval-js]
----
const trySomething = (x) => {
  if (x) {
    return x*42
  }
  console.log(`I cannot do ${x}`)
}
trySomething()
----
--

[%step]
--
Let's rewrite it as a pure function.
We will return an array with:

* the status
* the data

[source.eval-js]
----
trySomethingPure = (x) => {
  if (x) {
    return ["ok", x*42]
  }
  return ["error", `I cannot do ${x}`]
}
trySomethingPure(1)
----
--




== Declarative programming

compare for vs. each
you don't care about how the iteration is done
you care about what to to do with each element

== Immutability

Instead of mutating an object, you create a new version of it

== Laziness

We can deal with infinite sequences

[%step]
--
list all the integers in clojure
--

== A brief history of Functional Programming

[%step]
--
++++
<h3>1930: λ-calculus</h3>
++++
* Alonzo Church discovers the  https://en.wikipedia.org/wiki/Lambda_calculus[λ-calculus]
* Everything is a function
* Even numbers!
--

[%step]
--
++++
<h3>1958: LISP</h3>
++++
* John McCarthy invents https://en.wikipedia.org/wiki/Lisp_(programming_language)[LISP]
* It is the 1st FP language
* Everything is a S-Expression: `(+ 1 2 3)` instead of `1 + 2 + 3` or `+(1,2,3)`
* Only 7 terms: CAR, CDR, ATOM, LAMBDA, LABEL, COND, QUOTE
--

[%step]
--
++++
<h3>1995: Javascript the language of the browser</h3>
++++
* Brendan Eich is recruited by Netscape to do "scheme in the browser"
* Eventually, he invents Javascript
* Functions are 1st class citizens
--

== A brief history of Functional Programming (cont.)

* 2004 - Martin Odersky invents Scala - A JVM statically typed language with functional programming support
* 2007 - Rich Hickey invents Clojure - A practical dialect of LISP on top of JVM
* 2013 - Facebook creates react.js - A functional javascript frontend framework
* 2015 - Dan Abramov invents redux - A javascript library that imposes FP constraints on a frontend app
 
== Functional Programming in practice - Frontend

Many functional languages are transpiled in Javascript: Clojure, Scala, F#, Ocaml.

== Functional Programming in practice - ClojureScript

The power of Clojure in the browser!

== Functional Programming in practice - React.js

The UI is a (pure) function of the state (virtual DOM).
Do not mutate the state.
Write functions that manipulate the state instead of the DOM.
The framework will update the DOM efficiently.

== Functional Programming in practice - Redux

* Single source of truth
* State is read-only
* Changes are made with pure functions


== Functional Programming in practice - Backend (Web server, micro services)

The development process of a web server is much more effective with languages that support functional programming e.g. ruby.

Much less boilerplate: no need to write everything in an object.
Much simpler to manipulate data with maps (dictionaries) and arrays.

Sometimes, you need to leverage the java ecosystem.
No problem, let's build a functional that is compiled into Java ByteCode and creates a syntax for *interop*: interacting with the hosting language.

Scala, Clojure.

== Functional Programming in practice - Big Data

When we need to write a (relatively small) worker that is part of a computation pipe, we need a language:

- lightweight
- easy to manipulate JSON-like data
- combine functions
- immutability is effective
- stateless

Examples: Spark (scala), Storm (Clojure), Onyx (Clojure)



== Discussion and Questions

== References

include::klipse.adoc[]
++++
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.5.4/react-with-addons.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.5.4/react-dom.min.js"></script>
<script src="https://cdn.jsdelivr.net/ramda/0.23/ramda.min.js"></script>
++++
